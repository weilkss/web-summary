# web 前端面试题

想进大厂？首先基础得扎实，技术面试得过，你才能有机会和 hr 小姐姐谈工资

## 前端工程化

> 所谓工程化无非就是模块化、自动化、组件化、规范化

### 1. 什么是前端工程化？

> 前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间

1. **模块化**

简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载

2. **组件化**

从 UI 拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件

3. **自动化**

任何简单机械的重复劳动都应该让机器去完成

- 图标合并
- 持续继承
- 自动化构建
- 自动化部署
- 自动化测试

4. **规范化**

规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量

- 目录结构的制定
- 编码规范
- 前后端接口规范
- 文档规范

### 2. 什么是技术架构？

> 技术架构是指社会中各种技术之间相互作用、相互联系、按一定目的、一定结构方式组成的技术整体

归根揭底 —— 技术架构（技术体系）就是围绕业务发展、团队规模和团队特点量身打造的，最终目的都是在确保线上的质量和稳定性的前提下，来提升团队整体的开发效率

### 3. 什么是 Git？

> Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改

### 4. Git 和 SVN 有什么区别？

| Git                                    | SVN                                |
| -------------------------------------- | ---------------------------------- |
| Git 是一个分布式的版本控制工具         | SVN 是集中版本控制工具             |
| 它属于第 3 代版本控制工具              | 它属于第 2 代版本控制工具          |
| 客户端可以在其本地系统上克隆整个存储库 | 版本历史记录存储在服务器端存储库中 |
| 即使离线也可以提交                     | 只允许在线提交                     |
| Push/pull 操作更快                     | Push/pull 操作较慢                 |
| 工程可以用 commit 自动共享             | 没有任何东西自动共享               |

### 5. git pull 和 git fetch 有什么区别？

`git pull` 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支

`git fetch` 也用于相同的目的，但它的工作方式略有不同。当你执行 g`it fetch` 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 `git fetch` 之后执行 `git merge`。只有在对目标分支和获取的分支进行合并后才会更新目标分支

**so：** `git pull = git fetch + git merge`

### 6. git 历史版本回退

```shell
# 查看提交版本号信息
$ git log

# 切换到指定版本号
$ git reset --hard version
# git reset --hard a2456b6825a4cab009d53ba8bb2cd8a4eb425f6b

# 强制提交
$ git push -f
```

### 7. 查看分支是否已合并为 master？

```shell
# 它列出了已合并到当前分支的分支
$ git branch –merged

# 它列出了尚未合并的分支
$ git branch –no-merged
```

### 8. 项目上线流程是怎样的？

- **develop：** 本地开发
- **test：** 模拟线上的测试环境
- **rd：** 可连调的测试环境，即预发布
- **master：** 自动化的上线系统

### 9. 自动化部署

- jenkins
- gitlab-ci

### 10. AMD 和 CMD 的区别？

AMD 提前执行依赖，requirejs 是它的实现
CMD 按需执行依赖，seajs 是它的实现

### 11. 你都使用那些工具来测试代码性能？

- **JSPerf：** 是一个在线的代码片段性能测试工具，可以对某些代码片段进行性能测试，会自动输出对比的结果

### 12. 谈谈你所了解的 web 攻击技术

- **XSS（Cross-Site Scripting，跨站脚本攻击）：** 指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法 的 HTML 标签或者 JavaScript 进行的一种攻击。
- **SQL 注入攻击**
- **CSRF（Cross-Site Request Forgeries，跨站点请求伪造）：** 指攻击者通过设置好的陷阱，强制对已完成的认证用户进行非预期的个人信息或设定信息等某些状态更新。

### 说说 echarts

一个使用 JavaScript 实现的开源可视化数据图表库。作为一款基于 JavaScript 的数据可视化图表库，ECharts 为用户提供直观，生动，可交互，可个性化定制的数据可视化图表，让项目数据能清晰的被理解和发现差异

echarts 相当于一个壳子，有自己的主题、类型等一些配置，而核心 canvas 等部分则是采用 `ZRender`

ZRender 是一个 canvas 类库，MVC 封装，数据驱动，提供类 Dom 事件模型

### 微前端

微前端是由 ThoughtWorks 在 2016 年提出，即将一个完整的应用转变为数个可以独立存在并运行的子模块并聚合到一起到应用

- 应用随时间发展愈发臃肿，协作开发困难
- 应用体积过大，导致打包时间过长
- 让子模块可以灵活组合，并且易于对不同客户进行定制，并可以进行单独售卖模块

**好处:**

- 宏观角度
  - 可以独立部署不同的服务
  - 实现子应用间的隔离，即可以混用任何框架进行开发
  - 实现自治团队，具备独立迭代和创新的能力,方便多团队同时进行开发
  - 对外提供灵活的应用售卖方式
- 微观角度
  - 优化代码打包体积
  - 可以快速对子应用进行开发迭代，并像拼积木一样将不同对子应用拼接在一起
  - 代码库更小，更内聚、可维护性更高
  - 渐进地升级、更新甚至重写部分前端功能成为了可能

**不足:**

- 需要在开发中运行许多不同的应用来测试完整的应用体验
- 整个应用的版本控制变得复杂
- 多个子应用同时开发时需要频繁切换子应用
- 每个团队都有自己的技术选择，浏览器最终可能需要下载很多框架和重复代码，导致依赖项冗余，增加用户的流量负担
- 微前端的一些实现（特别是嵌入 iframe）可能会导致严重的可访问性问题

## 更多面试题

- [常见 css 的面试题](./css.md)
- [常见 html 的面试题](./html.md)
- [常见 javascript 的面试题](./javascript.md)
- [常见 typescript 的面试题](./typescript.md)
- [常见 vue 的面试题](./vue.md)
- [常见 react 的面试题](./react.md)
- [常见 webpack 的面试题](./webpack.md)
- [常见 node 的面试题](./node.md)
- [常见 web 算法面试题](./algorithm.md)
- [优化相关](./optimize.md)
